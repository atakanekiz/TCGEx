# Load the packages
library(dplyr)
library(shiny)
library(shinydashboard)
library(ggplot2)
library(plotROC)
library(broom)
library(DT)
library(msigdbr)
library(data.table)
library(shinyWidgets)
library(rintrojs)

roc_ui <- function(id, label, choices) {
  ns <- NS(id)
  tagList(
    
    add_busy_spinner(
      spin = "cube-grid",
      position = "top-right",
      color = "#01303f",
      margins = c(300, 500),
      height = "60px",
      width = "60px"),
    
    sidebarPanel(
      selectizeInput(inputId =ns("roc_definition_sel"), 
                     multiple=T,
                     label = "Select sample types",
                     choices=NULL, # will be updated dynamically
                     options=list(placeholder = "eg. Primary solid tumor")),
      selectizeInput(inputId =  ns("selectore"),
                     label= "Choose response variable",
                     choices = NULL,
                     multiple = FALSE),
      conditionalPanel(
        condition = "input.selectore == 'Categorical Values'",
        ns=ns,
        selectizeInput(inputId =  ns("binaryone"),
                       label= "Choose categorical data",
                       choices = NULL,
                       multiple = FALSE,
                       options=list(placeholder = "eg. meta.definition")),
        selectizeInput(inputId =  ns("binarytwo"),
                       label= "Choose values to binarized as 1 (desired outcome).",
                       choices = NULL,
                       multiple = TRUE,
                       options=list(placeholder = "eg. Solid Tissue Normal")),
        selectizeInput(inputId =  ns("binarythree"),
                       label= "Choose values to binarize as 0 (undesired outcome)",
                       choices = NULL,
                       multiple = TRUE,
                       options=list(placeholder = "eg. Primary solid tumor")),
      ),
      conditionalPanel(
        condition= "input.selectore == 'Numeric Values'",
        ns=ns, 
        selectizeInput(inputId =  ns("one_gene"),
                       label= "Choose numeric data",
                       choices = NULL,
                       multiple = FALSE,
                       options=list(placeholder = "eg. CD8A")),
        
        numericInput(inputId = ns("hi_cutoff_covar"), "High cutoff percent (Samples in this group will be binarized as 1)", 50, 1, 100),
        
        numericInput(inputId = ns("lo_cutoff_covar"), "Low cutoff percent (samples in this group will be binarized as 0)", 50, 1, 100)
        

      ),
      selectizeInput(inputId =  ns("genesss"), #Gene sets generated by user.
                     label= "Select gene(s) to create a custom predictor (multiple genes will be averaged)",
                     choices = NULL,
                     multiple = TRUE,
                     options=list(placeholder = "eg. TSPAN6, TNMD etc.")),
      materialSwitch(inputId = ns("show_msigdb_gene_sets"),
                     label = "Add MSigDB gene sets as a predictor",
                     status = "success",
                     value = FALSE),
      conditionalPanel(
        condition = "input.show_msigdb_gene_sets == true",
        ns = ns,
        selectInput(ns("cate"), "Select an MSigDB collection", 
                    choices = list(
                      # `Gene Sets` = list("H - Hallmark Gene Sets" = "H",
                      #                                 "C1 - Positional Gene Sets" = "C1",
                      #                                 "C6 - Oncogenic Signature Gene Sets" = "C6", 
                      #                                 "C8 - Cell Type Signature Gene Sets" = "C8"),
                      #              `C2 Subcategories` = list("CGP - Chemical and Genetic Perturbations" = "CGP", 
                      #                                        "CP - Canonical Pathways" = "CP", 
                      #                                        "BioCarta Pathway Subset of CP" = "CP:BIOCARTA", 
                      #                                        "KEGG Pathway Subset of CP" = "CP:KEGG", 
                      #                                        "PID Pathway Subset of CP" = "CP:PID", 
                      #                                        "Reactome Pathway Subset of CP" = "CP:REACTOME", 
                      #                                        "Wikipathways Pathway Subset of CP" = "CP:WIKIPATHWAYS"),
                      #              `C3 Subcategories` = list("MIR_Legacy Subset of microRNA Targets (MIR)" = "MIR:MIR_Legacy",
                      #                                        "miRDB Subset of microRNA Targets (MIR)" = "MIR:MIRDB",
                      #                                        "GTRD Subset of Transcription Factor Targets (TFT)" =  "TFT:GTRD", 
                      #                                        "TFT_Legacy Subset of Transcription Factor Targets (TFT)" =  "TFT:TFT_Legacy"),
                      #              `C4 Subcategories` = list("CGN - Cancer Gene Neighborhoods" = "CGN", 
                      #                                        "CM - Cancer Modules" =  "CM"),
                      #              `C5 Subcategories` = list("BP - Biological Process Subsets of Gene Ontology (GO)" = "GO:BP", 
                      #                                        "CC - Cellular Component Subsets of Gene Ontology (GO)" = "GO:CC", 
                      #                                        "MF - Molecular Function Subsets of Gene Ontology (GO)" = "GO:MF", 
                      #                                        "HPO - Human Phenotype Ontology subsets of Gene Ontology (GO)" = "HPO"),
                      #              `C7 Subcategories` = list("ImmuneSigDB Subset of C7" = "IMMUNESIGDB", 
                      #                                        "VAX - Vaccine Response Gene Sets" =  "VAX")
                      
                      `H: HALLMARK gene sets` = list("H"), 
                      `C1: Positional gene sets` = list("C1"),
                      `C2: Curated gene sets` = list("CGP", "CP", "CP:BIOCARTA", "CP:KEGG", "CP:PID", "CP:REACTOME", "CP:WIKIPATHWAYS"),
                      `C3: Regulatory target gene sets` = list("MIR:MIR_Legacy", "MIR:MIRDB", "TFT:GTRD", "TFT:TFT_Legacy"),
                      `C4: Computational gene sets` = list("CGN", "CM"),
                      `C5: Ontology gene sets` = list("GO:BP", "GO:CC", "GO:MF", "HPO"),
                      `C6: Oncogenic gene sets` = list("C6"),
                      `C7: Immunologic gene sets` = list("IMMUNESIGDB", "VAX"),
                      `C8: Cell type signature gene sets` = list("C8")
                                   
                    )),
        selectizeInput(ns("chosen_gs"), #Automatically updates to show subset.
                       "Select a specific gene set", 
                       choices = NULL)
      ),
      # p("Please click the ROC button after each change to refresh the plot and tables!"),
      actionBttn(inputId = ns("roc_run"), 
                 label = "Create ROC Curve",
                 style = "unite",
                 block = TRUE,
                 color = "primary"),
      br(),
      
      downloadButton(ns("downloadPlot5"), "Download ROC Plot", style="color: #eeeeee; background-color: #01303f; border-color: #01303f"),
      
      #help section UI
      
      introjsUI(),
      actionButton(ns("roc_help"), "App Tutorial", style="color: #FFFFFF; background-color: #81A1C1; border-color: #02a9f7"),
      
      
    ),
    mainPanel(
      plotOutput(outputId = ns("multi_plot"), width = "800px", height = "500px"), #ROC plot.
      DT::dataTableOutput(outputId = ns("auctable")), #Area Under Curve (AUC) value table from ROC plot.
      DT::dataTableOutput(outputId = ns("gene_set_table")) #Selected MSigDB gene names as a table.
    )
  )
}

roc_server <- function(id, Xproj) {
  moduleServer(
    id,
    function(input, output, session) {
      
      ns <- session$ns
      
      #Server part for app tutorial 
      
      roc_help_tutorial <- reactive({
        
        if(input$selectore == "Numeric Values"){
          
          return(
            data.frame(
              
              element = paste0("#", session$ns(c(NA, "roc_definition_sel + .selectize-control", "selectore + .selectize-control", "one_gene + .selectize-control ", "hi_cutoff_covar", "lo_cutoff_covar",  "genesss + .selectize-control ", "cate + .selectize-control ", "chosen_gs + .selectize-control "))),
              
              intro = paste(c(
                "This is the ROC (receiver operating characteristic) analysis module. In this module, you can binarize samples based on gene expression or categorical meta data and test the predictive power of a custom variable. ROC plots show True Positive Rate (TPR) and False Positive Rate (FPR) along the y- and x-axes, respectively. A completely random classifier would appear along the diagonal line in the graph and would have Area Under the Curve (AUC) of 0.5. The curve for a good positive predictor appears in the top half of the plot (AUC > 0.5), and the curve for a good negative predictor appears in the bottom half (AUC < 0.5). Continue the tutorial to learn how to use this module.",
                "Select sample types here to focus the analysis on specific subsets.",
                "ROC analysis is performed between two classes in the response variable as '1' (desired outcome group) and '0' (undesired outcome group). You can specify these classes for both categorical and numeric variables in the TCGA data. Here you need to select what kind of response variable you are interested in.",
                "Select the numerical variable you want to binarize here",
                "High cutoff input allows you to assign samples to class-1 if their values are more than the specified quantile here. For instance setting this value to 25 would mean binarizing the top 25% of the data as '1'. If you want to binarize at the median value this value should be 50 (default)",
                "Low cutoff input allows you to assign samples to class-0 if their values are less than the specified quantile here. For instance setting this value to 25 would mean binarizing the bottom 25% of the data as '0'. If you want to binarize at the median value this value should be 50 (default)",
                "Here, you select the predictor variable. If you enter more than one variable, their values will be averaged.",
                "If desired, the average expression value of a specific MSigDB gene set can be added to the graph.",
                "If you would like to include a curve for a specific MSigDB gene set, select it here."
              ))
            )
          )
        } else {
          return(
            
            data.frame(
              
              element = paste0("#", session$ns(c(NA, "roc_definition_sel + .selectize-control", "selectore + .selectize-control", "binaryone + .selectize-control ", "binarytwo + .selectize-control ", "binarythree + .selectize-control ", "genesss + .selectize-control ", "cate + .selectize-control ", "chosen_gs + .selectize-control "))),
              
              intro = paste(c(
                "This is the ROC (receiver operating characteristic) analysis module. In this module, you can binarize samples based on gene expression or categorical meta data and test the predictive power of a custom variable. ROC plots show True Positive Rate (TPR) and False Positive Rate (FPR) along the y- and x-axes, respectively. A completely random classifier would appear along the diagonal line in the graph and would have Area Under the Curve (AUC) of 0.5. The curve for a good positive predictor appears in the top half of the plot (AUC > 0.5), and the curve for a good negative predictor appears in the bottom half (AUC < 0.5). Continue the tutorial to learn how to use this module.",
                "Select sample types here to focus the analysis on specific subsets.",
                "ROC analysis is performed between two classes in the response variable as '1' (desired outcome group) and '0' (undesired outcome group). You can specify these classes for both categorical and numeric variables in the TCGA data. Here you need to select what kind of response variable you are interested in.",
                "You can select the categorical variable to binarize here. In the next step, you will decide which data subsets will be classified as 1 and 0.",
                "In this box, you can select which data subsets will be classified as '1'. For example, if you have chosen 'meta.gender' previously, you can choose 'female' observations to belong to class-1 here. If the categorical variable you selected has multiple subsets, you can specify more than one subset as well.",
                "In this box, you can select which data subsets will be classified as '0'. For example, if you have chosen 'meta.gender' previously, you can choose 'male' observations to belong to class-0 here. If the categorical variable you selected has multiple subsets, you can specify more than one subset as well.",
                "Here, you select the predictor variable. If you enter more than one variable, their values will be averaged.",
                "If desired, the average expression value of a specific MSigDB gene set can be added to the graph.",
                "If you would like to include a curve for a specific MSigDB gene set, select it here."
              ))
            )
          )
        }
   
      })
      
      
      observeEvent(input$roc_help, {
        
        introjs(session, options = list(steps = roc_help_tutorial() ) )
        
      })
      
      
      
      #Reactive selectboxes.
      observeEvent(input$binaryone,{
        req(input$binaryone)
        if(length(as.vector(input$binaryone)) == 0){
          return()
        }
        updateSelectizeInput(session = getDefaultReactiveDomain(),"binarytwo", choices = Xproj$a()[[input$binaryone]], server = TRUE)
      })
      
      observeEvent(input$binaryone,{
        req(input$binaryone)
        if(length(as.vector(input$binaryone)) == 0){
          return()
        }
        updateSelectizeInput(session = getDefaultReactiveDomain(),"binarythree", choices = Xproj$a()[[input$binaryone]], server = TRUE)
      })
      
      
      observe({updateSelectizeInput(session = getDefaultReactiveDomain(), "selectore", choices = c("Numeric Values", "Categorical Values"), server = TRUE)})
      observe({updateSelectizeInput(session = getDefaultReactiveDomain(), "one_gene", choices = colnames(Xproj$a()[, lapply(Xproj$a(), is.numeric) == TRUE, with = FALSE]), server = TRUE)})
      observe({updateSelectizeInput(session = getDefaultReactiveDomain(), "binaryone", choices = colnames(Xproj$a()[, lapply(Xproj$a(), is.factor) == TRUE, with = FALSE]), selected = "meta.definition", server = TRUE)})
      observe({updateSelectizeInput(session = getDefaultReactiveDomain(), "genesss", choices = colnames(Xproj$a()), server = TRUE)})
      observe({updateSelectizeInput(session = getDefaultReactiveDomain(), "roc_definition_sel", choices = c(Xproj$a()$meta.definition), selected = character(0), server = TRUE)})
      
      observeEvent(input$cate,{
        
        req(input$cate)
        req(df_gene_sets())
        
        updateSelectizeInput(session = getDefaultReactiveDomain(),"chosen_gs", choices = df_gene_sets()$gs_name, selected = character(0) ,server = TRUE)
        
      })
      
      pre_df <- eventReactive(input$roc_run,{
        
        #Creating the preliminary data.
        
        pre_df <- Xproj$a()
        
        req(input$roc_definition_sel)

        if(length(as.vector(input$roc_definition_sel)) > 0) {
            pre_df <- setDT(pre_df, key = 'meta.definition')[J(input$roc_definition_sel)]
            pre_df
        } else if (length(as.vector(input$roc_definition_sel)) == 0){
            pre_df
        }
        
        # Selected gene set means as a column.
        pre_df[, custom_gene_set := rowMeans(.SD, na.rm = TRUE), .SDcols = c(input$genesss)]  
        
        if(input$selectore == "Numeric Values"){
          
          # Selected Gene Value
          mid_value_roc <- ifelse(input$keep_mid_covar, "mid", NA)
          
          pre_df[, (input$one_gene) := ifelse(pre_df[[input$one_gene]] >= quantile(pre_df[[input$one_gene]], (100-input$hi_cutoff_covar)/100, na.rm = T), 1, ifelse(pre_df[[input$one_gene]] <= quantile(pre_df[[input$one_gene]], input$lo_cutoff_covar/100, na.rm = T), 0, mid_value_roc))]
          
        }else{
          # Selected Binary Value
          pre_df <- pre_df %>% 
            mutate(roccurve = case_when(
              pre_df[[input$binaryone]] == input$binarytwo ~ 1,
              pre_df[[input$binaryone]] == input$binarythree ~ 0
            ))
        }
      })
      
      
      df_gene_sets <- reactive({ 
        
        if(input$show_msigdb_gene_sets == TRUE){
          
          #Preparation of Human MSigDB genesets.
          
          if(input$cate %in% c("H", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8")){
            
            return({
              
              df_msigdb <- msigdbr(species = "human", category = input$cate)
              
              df_msigdb
              
            })
            
            
          } else if(input$cate %in% c("CGP", "CP", "CP:BIOCARTA", "CP:KEGG", "CP:PID", "CP:REACTOME", "CP:WIKIPATHWAYS",
                                      "MIR:MIR_Legacy", "MIR:MIRDB", "TFT:GTRD", "TFT:TFT_Legacy",
                                      "CGN", "CM",
                                      "GO:BP", "GO:CC", "GO:MF", "HPO",
                                      "IMMUNESIGDB", "VAX")){
            
            
            return({
              
              df_msigdb2 <- msigdbr(species = "human", category = NULL, subcategory = input$cate)
              
              df_msigdb2
              
            })}
        } else if(input$show_msigdb_gene_sets == FALSE){
          
          return({
            df_msigdb3 <- NULL
          })
        }
      })
      
      
      df_final_data <- eventReactive(input$roc_run,{
        
        #Preparation of final data.
        
        req(pre_df())
        
        if(input$show_msigdb_gene_sets == TRUE){
          
          req(input$chosen_gs)
          
          #Take the subset of chosen Human MsigDB geneset.
          
          df_final_gene_sets <- df_gene_sets()
          
          df_final_gene_sets <- setDT(df_final_gene_sets, key = 'gs_name')[J(input$chosen_gs)]
          
          # Drop and the Human MsigDB genes which are not in our data.
          
          df_unfiltered <- pre_df()
          
          same_hallmarks_names = intersect(df_final_gene_sets$gene_symbol, colnames(df_unfiltered))
          
          df_unfiltered[, selected_msigdb_gene_set := rowMeans(.SD, na.rm = TRUE), .SDcols = same_hallmarks_names]  
          
          df_unfiltered
          
        } else if(input$show_msigdb_gene_sets == FALSE){
          
          df_final_gene_sets <- pre_df()
          
        }
        
        
      })
      
      df_gene_set_table_calc <- eventReactive(input$roc_run, {
        
        if(input$show_msigdb_gene_sets == TRUE){
          
          #Preparation of Human MSigDB geneset table.
          
          req(df_gene_sets())
          
          req(input$chosen_gs)
          
          #Filter Human MSigDB genesets.
          
          df_final_gene_sets <- df_gene_sets()
          
          df_final_gene_sets <- setDT(df_final_gene_sets, key = 'gs_name')[J(input$chosen_gs)]
          
          #Choose columns to be kept and shown in the Human MSigDB geneset table.
          
          imp_cols <- c("gs_cat",
                        "gs_name",
                        "gene_symbol",
                        "ensembl_gene",
                        "entrez_gene")
          
          df_final_gene_sets <- df_final_gene_sets[,..imp_cols]
          
          df_final_gene_sets
          
        } else if(input$show_msigdb_gene_sets == FALSE){
          
          df_final_gene_sets <- df_gene_sets()
          
          df_final_gene_sets
        }
        
        
      })
      
      roc_multi_plot <- eventReactive(input$roc_run, {
        
        validate(need(input$roc_run, "Enter interactions and click Run ROC!"))
        
        if(input$selectore == "Numeric Values"){
          
          #Calculation of plot with the chosen numerical value.
          
          if(input$show_msigdb_gene_sets == TRUE){
            
            #Calculation of plot with the chosen multiple genes.
            
            validate(need(input$roc_definition_sel, "Please select a sample type"))
            validate(need(input$genesss, "Please select genes to create a custom predictor (multiple genes will be averaged)"))
            validate(need(input$chosen_gs, "Please select an MSigDB gene set"))
            
            longtest <- melt_roc(df_final_data(), input$one_gene, c("custom_gene_set", "selected_msigdb_gene_set"))
            multiplot1 <- ggplot(longtest, aes(d = D, m = M, color = name)) + geom_roc() + style_roc() + theme(legend.text = element_text(size = 18)) + geom_abline(slope = 1, intercept = 0, linetype = 2, color = "grey50") 
            
            return(print(multiplot1))
          } else if (input$show_msigdb_gene_sets == FALSE){
            
            #Calculation of plot with the chosen single gene.
            
            validate(need(input$roc_definition_sel, "Please select a sample type"))
            validate(need(input$one_gene, "Please choose gene expression data"))
            validate(need(input$genesss, "Please select genes to create a custom predictor (multiple genes will be averaged)"))
            
            basicplot <- ggplot(df_final_data(), aes(d = df_final_data()[[input$one_gene]], m = custom_gene_set)) + geom_roc() + geom_abline(slope = 1, intercept = 0, linetype = 2, color = "#030300") + coord_fixed()
            styledplotroc <- basicplot + style_roc() + annotate("text", x =.75, y =.25, label = paste ("AUC =", round (calc_auc (basicplot) ["AUC"], 2))) 
            
            return(print(styledplotroc))
          }
          
        }else{
          
          #Calculation of plot with the chosen binary value.
          
          validate(need(input$roc_definition_sel, "Please select a sample type"))
          validate(need(input$binaryone, "Please choose numeric variable to binarize"))
          validate(need(input$binarytwo, "Please choose value(s) to classify as class-1"))
          validate(need(input$binarythree, "Please choose value(s) to classify as class-0"))
          validate(need(input$genesss, "Please select gene(s) to create a custom predictor (multiple genes will be averaged)"))
          
          if(input$show_msigdb_gene_sets == TRUE){
            
            #Calculation of plot with the chosen multiple genes.
            validate(need(input$chosen_gs, "Please select an MSigDB gene set"))
            
            longtest <- melt_roc(df_final_data(), "roccurve", c("custom_gene_set", "selected_msigdb_gene_set"))
            multiplot2 <- ggplot(longtest, aes(d = D, m = M, color = name)) + geom_roc() + style_roc() + theme(legend.text = element_text(size = 18)) + geom_abline(slope = 1, intercept = 0, linetype = 2, color = "grey50") 
            
            return(print(multiplot2))
            
          } else if (input$show_msigdb_gene_sets == FALSE){
            
            #Calculation of plot with the chosen single gene.
            
            basicplot <- ggplot(df_final_data(), aes(d = roccurve, m = custom_gene_set)) + geom_roc() + geom_abline(slope = 1, intercept = 0, linetype = 2, color = "#030300") + coord_fixed()
            styledplot <- basicplot + style_roc() + annotate("text", x =.75, y =.25, label = paste ("AUC =", calc_auc (basicplot) ["AUC"])) 
            return(print(styledplot))
            
          }
        }
        
        
      })
      
      
      output$multi_plot <- renderPlot({
        
        # Output of the plot
        
        req(roc_multi_plot())
        
        print(roc_multi_plot())
        
      })
      
      
      roc_auc_data <- eventReactive(input$roc_run, {
        
        # Calculation for the area under curve (AUC).
        
        validate(need(input$roc_run, "Enter interactions and click Run ROC!"))
        
        if(input$selectore == "Numeric Values"){
          
          validate(need(input$genesss, "Select genes to create a custom predictor (Multiple genes will be averaged)"))
          
          fortable1 <- calc_auc(roc_multi_plot())
          return(fortable1)
          
        }else{
          
          validate(need(input$binaryone, "Please choose numeric variable to binarize"))
          validate(need(input$binarytwo, "Please choose value(s) to be classified as class-1"))
          validate(need(input$binarythree, "Choose second value(s) to be classified as class-0"))
          validate(need(input$genesss, "Select genes to create a custom predictor (multiple genes will be averaged)"))
          
          fortable2 <- calc_auc(roc_multi_plot())
          return(fortable2)
          
        }
        
        
      })
      
      
      output$auctable <- DT::renderDataTable({
        
        # Output for the area under curve (AUC).
        
        roc_auc_data()
        
      })
      
      
      observeEvent(input$roc_run, {
        
        #Output for the Human MSigDB geneset table.
        
        output$gene_set_table <- DT::renderDataTable({
          
          if(input$show_msigdb_gene_sets == TRUE){
            
            validate(need(input$roc_run, "Enter interactions and click Run ROC!"))
            
            df_gene_set_table_calc()
            
          }
          
        })
        
      })
      
      output$downloadPlot5 <- downloadHandler(
        filename = function() {
          paste("ROC_plot.png")
        },
        content = function(file) {
          
          png(file)
          print(roc_multi_plot())
          dev.off()
          
        })
      
      
    }
  )
}



